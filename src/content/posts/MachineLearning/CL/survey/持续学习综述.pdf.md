---
title: 持续学习综述
description: ""
image: ""
published: 2025-08-18
tags:
  - 论文阅读
  - 持续学习
  - 综述
category: 论文阅读
draft: false
path: "[[survey/持续学习综述.pdf|持续学习综述]]"
---

关键词：后训练 持续学习 开放世界 多模态学习

# 前言

为了应对真实世界的变化，一个优秀的模型应该能够增量的获取，更新并利用知识。这种能力被称为**持续学习**（continual learning），它为人工智能系统实现自适应发展提供了基础。从广义上讲，持续学习的主要障碍是**灾难性遗忘**（catastrophic forgetting），即学习新任务通常会导致模型在旧任务上的性能显著下降。在目前的实验下，我们将持续学习的目标总结为：实现适当的稳定性 - 可塑性权衡以及充分利用任务内与任务间的泛化能力。持续学习也被叫做终身学习或者增量学习

与传统的机器学习在静态的数据分布假设不同，持续学习的核心在于**如何在动态的数据分布**中进行学习。其中最重要的问题就是灾难性遗忘，也就是模型在适应新数据的分布时候会忘记老数据的分布。这一困境体现了“学习可塑性”与“记忆稳定性”之间的权衡：过度强调前者会干扰后者，反之亦然。通常来说使用所有旧的训练数据能解决上述问题，但是需要的资源开销太大。实际上持续学习的主要目的是**确保模型更新的资源效率，理想情况下应接近仅对新训练样本进行学习即可完成更新。**

当前的 CL 算法可以分为 5 大类：回放，架构，表示，正则化以及优化。

1. **基于正则化的方法**：通过参考旧模型添加正则化项；
2. **基于回放的方法**：近似和恢复旧数据分布；
3. **基于优化的方法**：显式地操纵优化程序；
4. **基于表示的方法**：学习鲁棒且分布良好的表示；
5. **基于架构的方法**：通过精心设计的架构构建任务自适应参数。

## 灾难性遗忘

从“哲学”上来说，假设模型的学习能力是固定的，模型在新任务上效果好，则在旧任务上效果会变差；反之，模型保持了旧任务上的效果，则在新任务上效果就不会好。前者是模型学习新知识的能力，称为**可塑性**（plasticity）；后者是旧知识的记忆能力，称为**稳定性**（stability）。可塑性与稳定性是内在相互矛盾的，术语叫**可塑性 - 稳定性困境**（Stability-Plasticity Dilemma），这是机器学习的一个天然的哲学约束，类似于 “没有免费午餐定理”。持续学习的目标是在所有任务上表现都好，即同时追求可塑性和稳定性；但这个困境说明了实现这一目标没有捷径，持续学习场景不是伪命题，并不是无脑加防遗忘机制、加强防遗忘的力度（例如调大防遗忘正则项超参数）就可以了，必须切实地提高模型的真本领。

除了灾难性遗忘作为核心问题，持续学习还关心算法是否具备：

- **后向迁移**（backward transfer）能力：学习后面的任务时，能否帮助到前面的任务；
- **前向迁移**（forward transfer）能力：学习前面的任务时，能否帮助到后面的任务。
拥有后向迁移能力是比克服灾难性遗忘还要厉害的事情。克服灾难性遗忘仅仅是学习后面的任务不会给前面的任务帮倒忙，而后向迁移还要求能帮正忙。按照我的理解，后向迁移能力与灾难性遗忘是同一种能力的两种程度。

拥有前向迁移能力意味着，在还没有见到要学习的任务时，就已经在积累该任务的知识，并且在训练该任务时用到。由于没有该任务的信息，这种能力也是最难拥有的，目前持续学习的研究基本无法触碰这个话题。

## 模型容量分配问题

持续学习的一大特点是学习任务的类型和数量没有预定义。在学习每个任务的期间，永远不知道未来有多少个任务、它们是什么样子的。我们不希望模型大小无序地膨胀，而是**固定模型容量**（capacity），让算法在固定容量的模型下完成持续学习（偶尔也会允许少量的膨胀）。

很显然，固定容量的模型，随着任务越来越多，模型也不能容纳所有的知识，会出现**模型容量饱和**（capacity saturation）问题。知识必须有所舍弃，各任务上的效果也会打折扣，遗忘也就越严重。由于深度学习基于的是参数化的神经网络模型，这个问题是不可能解决的，因为参数是会被覆写的，模型的表示能力是有限的。目前持续学习的研究致力于**缓解这个问题，而不是彻底解决它**。一个好的持续学习算法能让模型尽量记住任务重要的知识，在需要舍弃知识时舍弃不重要的，减少模型表示上的重叠或冗余，从而减缓遗忘的速度。

在学习中，每个任务都会占据一定的容量，任务间也会占用部分容量，因此我们需要在算法中加入稀疏化来解决模型容量不足的问题。

# 学习曲线

在训练过程中我们需要对学习曲线进行监视，持续学习有多个任务，就有多个独立的学习曲线，我们更关注是否会出现灾难性遗忘，所以需要监视模型在旧任务上的表现。

![image.png](https://picture-bed-1325530970.cos.ap-nanjing.myqcloud.com/20250816133124522.png)

# 设定

## 基本公式

持续学习被认为是从动态的数据分布中进行学习，在实际中，不同分布的训练样本按批次抵达，一个模型 $\theta$ 需要在对旧数据有限的接触的情况下学习对应的任务 $s$ 并且在测试集上表现良好,属于任务 $t$ 的一组样本表示为 $\mathcal{D}_{t,b}=\{\mathcal{X}_{t,b}.\mathcal{Y}_{t,b}\}$，其中 x 是输入数据，y 是对应的标签，$t \in \mathcal{T} = \{1, \cdots, k\}$ 是任务标识，$b \in \mathcal{B}_t$ 是批次索引。每个任务 $t$ 的样本都服从分布 $\mathbb{D}_{t}:=p(\mathcal{X}_{t},\mathcal{Y}_{t})$，并且训练和测试的分布没有区别。但是通常标签和任务标识并非总是可用，每个任务的 batch 能够按批次到达也可以同时到达。

## 评判标准

通常可以从三个方面来评估持续学习的效果：**迄今为止所学任务的整体性能、旧任务的记忆稳定性以及新任务的学习可塑性。**

### Overall Performance

通常使用 average accuracy 和 average incremental accuracy 来评估总体性能。令 $a_{k,j}$ 是在训练了 k 个任务后的第 j 个任务上的分类准确率，指标如下：

$$
\text{AA}_k = \frac{1}{k} \sum_{j=1}^{k} a_{k,j}
$$

$$
\text{AIA}_k = \frac{1}{k} \sum_{i=1}^{k} \text{AA}_i
$$

这里的 AA 表示当前的总体准确率，AIA 更多的反应了历史准确率

### Memory Stability

记忆稳定性可以通过遗忘度量（forgetting measure）和向后迁移 (backward transfer) 来评估

对于前者，对任务的遗忘可以通过以往最大性能和现在的性能来计算

$$
f_{j,k} = \max_{i \in \{1, \ldots, k-1\}} (a_{i,j} - a_{k,j}), \quad \forall j < k. \tag{3}
$$

在第 $k$ 个任务时，FM 是所有旧任务平均遗忘程度：

$$
\text{FM}_k = \frac{1}{k - 1} \sum_{j=1}^{k-1} f_{j,k}. \tag{4}
$$

于后者，BWT 评估学习第 $k$ 个任务对所有旧任务的平均影响：

$$
\text{BWT}_k = \frac{1}{k - 1} \sum_{j=1}^{k-1} (a_{k,j} - a_{j,j}), \tag{5}
$$

其中，遗忘通常表现为负的 BWT 值。

### Learning Plasticity

学习可塑性能通过不可转移性度量（Intransience Measure, IM）] 和向前迁移（Forward Transfer, FWT）来评估。

IM 被定义为模型学习新任务能力的不足，通过某一任务在联合训练性能与持续学习性能之间的差异来计算：

$$
\text{IM}_k = a_k^* - a_{k,k}
$$

这里的其中 $a_k^*$ 是一个随机初始化的参考模型在联合训练所有前 $k$ 个任务数据 $\bigcup_{j=1}^k D_j$ 后，在第 $k$ 个任务上的分类准确率。相比之下，FWT 评估所有旧任务对当前第 $k$ 个任务的平均影响：

$$
\text{FWT}_k = \frac{1}{k - 1} \sum_{j=2}^{k} (a_{j,j} - \bar{a}_j), \tag{7}
$$

其中 $\bar{a}_j$ 是一个随机初始化的参考模型仅使用第 $j$ 个任务的数据 $D_j$ 进行训练后在该任务上的分类准确率。

需要注意的是，$a_{k,j}$ 可以根据任务类型调整为其他形式，例如目标检测中的平均精度（AP）、语义分割中的交并比（IoU）、图像生成中的弗雷赫特 inception 距离（FID）、强化学习中的归一化奖励 等，上述评估指标也应相应地进行调整。

# 理论基础

现在有一个网络 $\theta$ 需要学习 $k$ 个增量任务，每个任务的训练集和训练集有同样的分布 $\mathbb{D}_{t}$,目标是学习一个模型分布 $$p(\mathcal{D}_{1:k}|\theta) = \prod_{t=1}^k p(\mathcal{D}_t|\theta)$$

在连续学习中，旧的训练集是无法被访问的，因此，同时平衡的捕捉新老数据集的分布很重要但是具有挑战。

一个直观的想法是通过存储少量旧的训练样本或训练一个生成模型来近似并恢复旧数据的分布，这种方法叫做基于回放的方法，通过重放更多能够近似其分布的旧训练样本，可以提升对旧任务的性能，但这种方法可能带来潜在的隐私问题，并导致资源开销呈线性增长。此外，使用生成模型也受到巨大额外资源开销的限制，同时它们自身还存在灾难性遗忘和表达能力不足的问题。

另一种选择是在贝叶斯框架下，通过在更新参数时传播旧数据分布来构建连续学习，基于网络参数的先验 $p(\theta)$，在观测到第 $k$ 个任务后，其后验概率可通过贝叶斯规则计算：

$$
p(\theta|\mathcal{D}_{1:k}) \propto p(\theta) \prod_{t=1}^k p(\mathcal{D}_t|\theta) \propto p(\theta|\mathcal{D}_{1:k-1}) p(\mathcal{D}_k|\theta)\tag{8}
$$

其中，第 $(k-1)$ 个任务的后验 $p(\theta|\mathcal{D}_{1:k-1})$ 成为第 $k$ 个任务的先验，从而使得新的后验 $p(\theta|\mathcal{D}_{1:k})$ 可以仅利用当前训练集 $\mathcal{D}_k$ 进行计算。然而，由于后验通常难以解析求解（除了一些非常特殊的情况），一种常见做法是用 $q_{k-1}(\theta) \approx p(\theta|\mathcal{D}_{1:k-1})$ 来近似它，类似地，$q_k(\theta) \approx p(\theta|\mathcal{D}_{1:k})$。

## 在线拉普拉斯近似

第一种策略是在线拉普拉斯近似，使用局部梯度信息将 $p(\theta|\mathcal{D}_{1:k-1})$ 近似为多元高斯分布，具体来说，我们可以用参数 $\phi_{k-1} = \{\mu_{k-1}, \Lambda_{k-1}\}$ 来参数化近似后验 $q_{k-1}(\theta)$，并构造一个近似的高斯后验：

$$
q_{k-1}(\theta) := q(\theta; \phi_{k-1}) = \mathcal{N}(\theta; \mu_{k-1}, \Lambda_{k-1}^{-1})
$$

这可以通过在 $p(\theta|\mathcal{D}_{1:k-1})$ 的众数点 $\mu_{k-1} \in \mathbb{R}^{|\theta|}$ 附近进行二阶泰勒展开实现，其中 $\Lambda_{k-1}$ 表示精度矩阵（precision matrix），$\phi_k = \{\mu_k, \Lambda_k\}$ .

根据公式 (8)，学习当前第 $k$ 个任务的后验众数可以计算为：

$$
\begin{aligned}
\mu_k &= \arg\max_\theta \log p(\theta|D_{1:k}) \\
&\approx \arg\max_\theta \log p(D_k|\theta) + \log q(\theta; \phi_{k-1}) \\
&= \arg\max_\theta \log p(D_k|\theta) - \frac{1}{2}(\theta - \mu_{k-1})^\top \Lambda_{k-1} (\theta - \mu_{k-1}),
\end{aligned}
\tag{9}
$$

该结果从 $\mu_{k-1}$ 和 $\Lambda_{k-1}$ 递归更新得到。同时，$\Lambda_k$ 也从 $\Lambda_{k-1}$ 递归更新：

$$
\begin{aligned}
\Lambda_k &= -\nabla_\theta^2 \log p(\theta|D_{1:k})\big|_{\theta=\mu_k} \\
&\approx -\nabla_\theta^2 \log p(D_k|\theta)\big|_{\theta=\mu_k} + \Lambda_{k-1},
\end{aligned}
\tag{10}
$$

其中，右侧第一项是数据集 $\mathcal{D}_k$ 在参数 $\mu_k$ 处的负对数似然的海森矩阵，记作 $H(\mathcal{D}_k, \mu_k)$。在实际应用中，由于 $\mathbb{R}^{|\theta|}$ 的高维性，计算 $H(\mathcal{D}_k, \mu_k)$ 通常效率较低，且无法保证近似的 $\Lambda_k$ 满足高斯假设下的半正定性。为克服这些问题，通常用费希尔信息矩阵来近似海森矩阵：

$$
F_k = \mathbb{E}[\nabla_\theta \log p(\mathcal{D}_k|\theta)\nabla_\theta \log p(\mathcal{D}_k|\theta)^\top]\big|_{\theta=\mu_k} \approx H(\mathcal{D}_k, \mu_k).
\quad (11)
$$

为了便于计算，FIM 可进一步简化为对角近似 或克罗内克分解近似。然后，式 (9) 通过保存旧模型 $\mu_{k-1}$ 的一个“冻结”副本以正则化参数变化来实现，这种方法被称为基于正则化的策略，详见第 4.1 节。

这里我们以 EWC 为例，并给出其损失函数：

$$
\mathcal{L}_{\text{EWC}}(\theta) = \ell_k(\theta) + \frac{\lambda}{2} (\theta - \mu_{k-1})^\top \hat{F}_{1:k-1} (\theta - \mu_{k-1}),
\quad (12)
$$

其中 $\ell_k$ 表示任务特定的损失函数，$\hat{F}_{1:k-1} = \sum_{t=1}^{k-1} \mathrm{diag}(F_t)$ 是每个 $F_t$ 的对角近似 $\mathrm{diag}(\cdot)$ 的累加，而 $\lambda$ 是一个超参数，用于控制正则化的强度。

## 在线变分推断

实现这一目标的方法有很多，其中一种代表性方法是在满足 $p(\theta|\mathcal{D}_{1:k}) \in \mathcal{Q}$ 的函数族 $\mathcal{Q}$ 上最小化如下 KL 散度：

$$
q_k(\theta) = \arg\min_{q \in \mathcal{Q}} \mathrm{KL}\big(q(\theta) \,\|\, \frac{1}{Z_k} q_{k-1}(\theta)p(\mathcal{D}_k|\theta)\big), \quad (13)
$$

其中 $Z_k$ 是 $q_{k-1}(\theta)p(\mathcal{D}_k|\theta)$ 的归一化常数。在实际应用中，上述最小化问题可以通过引入一个额外的蒙特卡洛近似来实现，例如设定 $q_k(\theta) := q(\theta; \phi_k) = \mathcal{N}(\theta; \mu_k, \Lambda_k^{-1})$ 为多元高斯分布。这里我们以 VCL 为例，它最小化以下目标函数（即最大化其负值）：

$$
\mathcal{L}_{\text{VCL}}(q_k(\theta)) = \mathbb{E}_{q_k(\theta)}(\ell_k(\theta)) + \mathrm{KL}(q_k(\theta) \,\|\, q_{k-1}(\theta)), \quad (14)
$$

>[!todo]

从本质上看,不论是回放还是正则化,他们对持续学习的最终约束都是在梯度上,因此，一些近期的工作直接操纵基于梯度的优化过程，比如当学完了任务 t 后,保留少量的样本

从本质上看，无论是回放（replay）还是正则化方法，对持续学习的约束最终都体现在梯度方向上。因此，一些近期的工作直接操纵基于梯度的优化过程，这类方法被归类为“基于优化的方法”。具体而言，当为任务 $t$ 保留少量旧训练样本 $\mathcal{M}_t$ 存储在记忆缓冲区中时，新训练样本的梯度方向被鼓励尽可能接近旧样本 $\mathcal{M}_t$ 的梯度方向。这可以形式化为：

$$
\langle \nabla_\theta \mathcal{L}_k(\theta; \mathcal{D}_k), \nabla_\theta \mathcal{L}_k(\theta; \mathcal{M}_t) \rangle \geq 0 \quad \text{for } t \in \{1, \ldots, k-1\},
$$

从而实质上强制旧任务的损失不增加，即 $\mathcal{L}_k(\theta; \mathcal{M}_t) \leq \mathcal{L}_k(\theta_{k-1}; \mathcal{M}_t)$，其中 $\theta_{k-1}$ 是学习完第 $(k-1)$ 个任务后网络的参数。

另一种替代方法是进行梯度投影，而无需存储旧的训练样本。这里以 NCL 为例，该方法通过在线拉普拉斯近似中的 $\mu_{k-1}$ 和 $\Lambda_{k-1}$ 来操控梯度方向。如公式 (15) 所示，NCL 通过在以 $\theta$ 为中心、半径为 $r$ 的区域内最小化任务特定损失 $\ell_k(\theta)$ 实现持续学习，该区域采用距离度量 $d(\theta, \theta + \delta) = \sqrt{\delta^\top \Lambda_{k-1} \delta / 2}$，该度量考虑了先验的曲率，其由精度矩阵 $\Lambda_{k-1}$ 决定：

$$
\begin{aligned}
\delta^* &= \arg\min_\delta \ell_k(\theta + \delta) \\
&\approx \arg\min_\delta \ell_k(\theta) + \nabla_\theta \ell_k(\theta)^\top \delta, \\
&\text{s.t. } d(\theta, \theta + \delta) = \sqrt{\delta^\top \Lambda_{k-1} \delta / 2} \leq r.
\end{aligned} \quad (15)
$$

对于公式 (15) 中的优化问题，其解为 $\delta^* \propto \Lambda_{k-1}^{-1} \nabla_\theta \ell_k(\theta) - (\theta - \mu_{k-1})$，由此导出如下学习率为 $\lambda$ 的更新规则：

$$
\theta \leftarrow \theta + \lambda [\Lambda_{k-1}^{-1} \nabla_\theta \ell_k(\theta) - (\theta - \mu_{k-1})], \quad (16)
$$

其中第一项鼓励参数变化主要发生在不会干扰旧知识的方向上。

## 泛化性分析

目前关于持续学习的理论研究主要集中在增量任务的训练集上，假设其测试集遵循相似的分布，并且候选解决方案具有相似的泛化能力。然而，由于多任务学习的目标函数通常高度非凸，存在许多局部最优解，这些解在每个训练集上的表现相似，但在测试集上的泛化能力却有显著差异,对于持续学习而言，理想的解决方案不仅需要具备从训练集到测试集的**任务内泛化能力**，还需要具备**任务间泛化能力**，以适应其分布的增量变化.

这里我们提供了一个任务特定的损失函数 $l_{t}(\theta,D_{t})$ 以及其经验最优解 $\theta^*_{t}=argmin_{\theta}l_{t}(\theta,D_{t})$,来说明.当任务 i 需要适应另一个任务 j 的时候,其性能的最大损耗可以通过 $l$ 在 $\theta_{i}^*$ 附近的二阶泰勒展开来估计:

$$
\begin{align}
\ell_i(\theta_j^*; \mathcal{D}_i) \approx \ell_i(\theta_i^*; \mathcal{D}_i) + (\theta_j^* - \theta_i^*)^\top \nabla_\theta \ell_i(\theta; \mathcal{D}_i)\big|_{\theta=\theta_i^*}+ \\
 \frac{1}{2} (\theta_j^* - \theta_i^*)^\top \nabla_\theta^2 \ell_i(\theta; \mathcal{D}_i)\big|_{\theta=\theta_i^*} (\theta_j^* - \theta_i^*) \tag{19}\\
\approx \ell_i(\theta_i^*; \mathcal{D}_i) + \frac{1}{2} \Delta\theta^\top \nabla_\theta^2 \ell_i(\theta;\mathcal{D}_i)\big|_{\theta=\theta_i^*} \Delta\theta,
\end{align}
$$

其中 $\Delta\theta := \theta_j^* - \theta_i^*$，且 $\nabla_\theta \ell_i(\theta; \mathcal{D}_i)\big|_{\theta=\theta_i^*} \approx \mathbf{0}$。于是，任务 $i$ 的性能下降可以上界为：

$$
\ell_i(\theta_j^*; \mathcal{D}_i) - \ell_i(\theta_i^*; \mathcal{D}_i) \leq \frac{1}{2} \lambda_i^{max} \|\Delta\theta\|^2,
\tag{20}
$$

其中 $\lambda_i^{max}$ 是 Hessian 矩阵 $\nabla_\theta^2 \ell_i(\theta; \mathcal{D}_i)\big|_{\theta=\theta_i^*}$ 的最大特征值。注意，任务 $i$ 和 $j$ 的顺序可以是任意的，也就是说，公式 (20) 同时体现了前向和后向的影响。因此，经验最优解 $\theta_i^*$ 对参数变化的鲁棒性与 $\lambda_i^{max}$ 密切相关，而 $\lambda_i^{max}$ 已被广泛用作描述损失函数景观平坦程度的常用指标.

直观上，收敛到一个损失景观更平坦的局部极小值，将对参数的微小变化不那么敏感从而同时有利于旧任务和新任务

![image.png](https://picture-bed-1325530970.cos.ap-nanjing.myqcloud.com/20250819094741257.png)

# 遗憾界

模型的训练方式可以分为两种,在线学习和批量学习

1. 批量学习: 模型依次学完,用一些指标来评价,好就是好,坏就是坏,没有遗憾
2. 在线学习: 模型一直学习,不断成长,试图成为完美的模型,但是哪来的完美,这就有了遗憾
模型在迭代了 T 轮后,累计的损失为:$\sum^{T}_{t=1}f_t{w_{t}}$
遗憾就是累计损失和理想的最小损失的差值:

$$
regret = \sum^{T}_{t=1}f_t{w_{t}}-min\sum^{T}_{t=1}f_t{w_{t}}
$$

目的就是在 T 趋向去♾️的时候 regret/T 趋向于 0
